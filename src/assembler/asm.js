app.service('uploader', ['opcodes', function (opcodes) {
    return {
        go: function (input) {
            // Contains the program code & data generated by the assembler
            var code = [];
            // Contains the mapping from instructions to assembler line
            var mapping = {};
            // Hash map of label used to replace the labels after the assembler generated the code
            var labels = {};
             // Split text into code lines
            var lines = input.split('\n');
            for (var i = 0, l = lines.length; i < l; i++) {
                  var codes = input.split(' ');
                  for (var j = 0, codenum = codes.length; j < codenum; j++) {
                          var codevalue=parseInt(codes[j].slice(0,2), 16);
                          if (codevalue < 0 || codevalue > 255) {
                                throw "code must be a value between 0...255";
                          }
                          code.push(codevalue);
                   }
             }
             return {code: code, mapping: mapping, labels: labels};
        }
    };
}]);

app.service('assembler', ['opcodes', function (opcodes) {
    return {
        go: function (input) {
            // Use https://www.debuggex.com/
            // Matches: "label: INSTRUCTION (["')OPERAND1(]"'), (["')OPERAND2(]"'), (["')OPERAND3(]"')
            // GROUPS:      1       2               3                    7
            //var regex = /^[\t ]*(?:([.A-Za-z]\w*)[:])?(?:[\t ]*([A-Za-z]{2,4})(?:[\t ]+(\[(\w+((\+|-)\d+)?)\]|\".+?\"|\'.+?\'|[.A-Za-z0-9]\w*)(?:[\t ]*[,][\t ]*(\[(\w+((\+|-)\d+)?)\]|\".+?\"|\'.+?\'|[.A-Za-z0-9]\w*))?)?)?/;
            //var regex = /^[\t ]*(?:([.A-Za-z]\w*)[:])?(?:[\t ]*([A-Za-z]{2,6})(?:[\t ]+(\[(\w+((\+|-)\d+)?)\]|\".+?\"|\'.+?\'|[.A-Za-z0-9]\w*)(?:[\t ]*[,][\t ]*(\[(\w+((\+|-)\d+)?)\]|\".+?\"|\'.+?\'|[.A-Za-z0-9]\w*)(?:[\t ]*[,][\t ]*(\[(\w+((\+|-)\d+)?)\]|\".+?\"|\'.+?\'|[.A-Za-z0-9]\w*))?)?)?)?/;
            var regex = /^[\t ]*(?:([.A-Za-z]\w*)[:])?(?:[\t ]*([A-Za-z]{2,6})(?:[\t ]+(\[(\w+((\+|-)\d+)?)\]|\".+?\"|\'.+?\'|[.A-Za-z0-9]\w*)(?:[\t ]*[,][\t ]*(\[(\w+((\+|-)\d+)?)\]|\".+?\"|\'.+?\'|[.A-Za-z0-9]\w*)(?:[\t ]*[,][\t ]*(\[(\w+((\+|-)\d+)?)\]|\".+?\"|\'.+?\'|[.A-Za-z0-9]\w*))?)?)?)?/;
            //^[\t ]*(?:([.A-Za-z]\w*)[:])?  -- label: or nothing
            //(?:[\t ]*([A-Za-z]{2,5})       -- instruction
            //(?:[\t ]+(\[(\w+((\+|-)\d+)?)\]|\".+?\"|\'.+?\'|[.A-Za-z0-9]\w*)(?:[\t ]*  -- (["')OPERAND1(]"')
            // Regex group indexes for operands
            var op1_group = 3;
            var op2_group = 7;
            var op3_group = 11;
            // MATCHES: "(+|-)INTEGER"
            var regexNum = /^[-+]?[0-9]+$/;
            // MATCHES: "(.L)abel"
            var regexLabel = /^[.A-Za-z]\w*$/;
            // Contains the program code & data generated by the assembler
            var code = [];
            // Contains the mapping from instructions to assembler line
            var mapping = {};
            // Hash map of label used to replace the labels after the assembler generated the code
            var labels = {};
            // Hash of uppercase labels used to detect duplicates
            var normalizedLabels = {};

            // Split text into code lines
            var lines = input.split('\n');

            // Allowed formats: 200, 200d, 0xA4, 0o48, 101b
            var parseNumber = function (input) {
                if (input.slice(0, 2) === "0x") {
                    return parseInt(input.slice(2), 16);
                } else if (input.slice(0, 2) === "0o") {
                    return parseInt(input.slice(2), 8);
                } else if (input.slice(input.length - 1) === "b") {
                    return parseInt(input.slice(0, input.length - 1), 2);
                } else if (input.slice(input.length - 1) === "d") {
                    return parseInt(input.slice(0, input.length - 1), 10);
                } else if (regexNum.exec(input)) {
                    return parseInt(input, 10);
                } else {
                    throw "Invalid number format";
                }
            };

            // Allowed registers: R0 - RF
            var parseRegister = function (input) {
                input = input.toUpperCase();

                if (input === 'R0') {
                    return 0;
                } else if (input === 'R1') {
                    return 1;
                } else if (input === 'R2') {
                    return 2;
                } else if (input === 'R3') {
                    return 3;
                } else if (input === 'R4') {
                    return 4;
                } else if (input === 'R5') {
                    return 5;
                } else if (input === 'R6') {
                    return 6;
                } else if (input === 'R7') {
                    return 7;
                } else if (input === 'R8') {
                    return 8;
                } else if (input === 'R9') {
                    return 9;
                } else if (input === 'RA') {
                    return 10;
                } else if (input === 'RB') {
                    return 11;
                } else if (input === 'RC') {
                    return 12;
                } else if (input === 'RD') {
                    return 13;
                } else if (input === 'RE') {
                    return 14;
                } else if (input === 'RF') {
                    return 15;
                } else {
                    return undefined;
                }
            };

            // Allowed: Register, Label or Number; NO!!!(SP+/-Number is allowed for 'regaddress' type)
            var parseRegOrNumber = function (input, typeReg, typeNumber) {
                var register = parseRegister(input);

                if (register !== undefined) {
                    return {type: typeReg, value: register};
                } else {
                    var label = parseLabel(input);
                    if (label !== undefined) {
                        return {type: typeNumber, value: label};
                    } else {
                        var value = parseNumber(input);

                        if (isNaN(value)) {
                            throw "Not a " + typeNumber + ": " + value;
                        }
                        else if (value < 0 || value > 255)
                            throw typeNumber + " must have a value between 0-255";

                        return {type: typeNumber, value: value};
                    }
                }
            };

            var parseLabel = function (input) {
                return regexLabel.exec(input) ? input : undefined;
            };

            var getValue = function (input) {
                switch (input.slice(0, 1)) {
                    case '"': // "String"
                        var text = input.slice(1, input.length - 1);
                        var chars = [];

                        for (var i = 0, l = text.length; i < l; i++) {
                            chars.push(text.charCodeAt(i));
                        }

                        return {type: "numbers", value: chars};
                    case "'": // 'C'
                        var character = input.slice(1, input.length - 1);
                        if (character.length > 1)
                            throw "Only one character is allowed. Use String instead";

                        return {type: "number", value: character.charCodeAt(0)};
                    default: // REGISTER, NUMBER or LABEL
                        return parseRegOrNumber(input, "register", "number");
                }
            };

            var addLabel = function (label) {
                var upperLabel = label.toUpperCase();
                if (upperLabel in normalizedLabels)
                    throw "Duplicate label: " + label;

                if (upperLabel === "R0" || upperLabel === "R1" || upperLabel === "R2" || upperLabel === "R3" || upperLabel === "R4" || upperLabel === "R5" || upperLabel === "R6" || upperLabel === "R7" ||upperLabel === "R8" || upperLabel === "R9" || upperLabel === "RA" || upperLabel === "RB" ||upperLabel === "RC" || upperLabel === "RD" || upperLabel === "RE" || upperLabel === "RF")
                    throw "Label contains keyword: " + upperLabel;

                labels[label] = code.length;
            };

            var checkNoExtraArg = function (instr, arg) {
                if (arg !== undefined) {
                    throw instr + ": too many arguments";
                }
            };

            for (var i = 0, l = lines.length; i < l; i++) {
                try {
                    var match = regex.exec(lines[i]);
                    if (match[1] !== undefined || match[2] !== undefined) {
                        if (match[1] !== undefined) {
                            addLabel(match[1]);
                        }

                        if (match[2] !== undefined) {
                            var instr = match[2].toUpperCase();
                            var p1, p2, p3, opCode;

                            // Add mapping instr pos to line number
                            // Don't do it for DB as this is not a real instruction
                            if (instr !== 'DB') {
                                mapping[code.length] = i;
                            }

                            switch (instr) {
                                case 'DB':
                                    p1 = getValue(match[op1_group]);

                                    if (p1.type === "number")
                                        code.push(p1.value);
                                    else if (p1.type === "numbers")
                                        for (var j = 0, k = p1.value.length; j < k; j++) {
                                            code.push(p1.value[j]);
                                        }
                                    else
                                        throw "DB does not support this operand";

                                    break;
                                case 'HALT':
                                    checkNoExtraArg('HALT', match[op1_group]);
                                    checkNoExtraArg('HALT', match[op2_group]);
                                    checkNoExtraArg('HALT', match[op3_group]);
                                    opCode = opcodes.HALT;
                                    code.push(opCode<<4,0);
                                    break;

                                case 'MOVE':
                                    p1 = getValue(match[op1_group]);
                                    p2 = getValue(match[op2_group]);
                                    checkNoExtraArg('MOVE', match[op3_group]);
                                    if (p1.type === "register" && p2.type === "register")
                                        opCode = opcodes.MOVE;
                                    else
                                        throw "MOVE does not support this operands";

                                    code.push(opCode<<4, (p2.value<<4)|p1.value);
                                    break;
                                case 'ADDI':
                                    p1 = getValue(match[op1_group]);
                                    p2 = getValue(match[op2_group]);
                                    p3 = getValue(match[op3_group]);
                                    if (p1.type === "register" && p2.type === "register" && p3.type === "register")
                                        opCode = opcodes.ADD_INT;
                                    else
                                        throw "ADD_INT does not support this operands";

                                    code.push(opCode<<4|p1.value, p2.value<<4|p3.value);
                                    break;
                                case 'ADDF':
                                    p1 = getValue(match[op1_group]);
                                    p2 = getValue(match[op2_group]);
                                    p3 = getValue(match[op3_group]);
                                    if (p1.type === "register" && p2.type === "register" && p3.type === "register")
                                        opCode = opcodes.ADD_FLOAT;
                                    else
                                        throw "ADD_FLOAT does not support this operands";

                                    code.push(opCode<<4|p1.value, p2.value<<4|p3.value);
                                    break;
                                case 'LOAD':
                                    p1 = getValue(match[op1_group]);
                                    p2 = getValue(match[op2_group]);
                                    checkNoExtraArg('LOAD', match[op3_group]);

                                    if (p1.type === "register" && p2.type === "number" )
                                        opCode = opcodes.LOAD_FROM_MEMORY;
                                    else
                                        throw "LOAD does not support this operands";

                                    code.push(opCode<<4 | p1.value, p2.value);
                                    break;
                                case 'LOADI':
                                    p1 = getValue(match[op1_group]);
                                    p2 = getValue(match[op2_group]);
                                    checkNoExtraArg('LOADI', match[op3_group]);

                                    if (p1.type === "register" && p2.type === "number" )
                                        opCode = opcodes.LOAD_WITH_CONSTANT;
                                    else
                                        throw "LOADI does not support this operands";

                                    code.push(opCode<<4 | p1.value, p2.value);
                                    break;
                                case 'LOADP':
                                    p1 = getValue(match[op1_group]);
                                    p2 = getValue(match[op2_group]);
                                    checkNoExtraArg('LOADP', match[op3_group]);
                                    if (p1.type === "register" && p2.type === "register")
                                        opCode = opcodes.LOAD_FROM_POINTER;
                                    else
                                        throw "LOADP does not support this operands";

                                    code.push(opCode<<4|p1.value, p2.value);
                                    break;

                                case 'STORE':
                                    p1 = getValue(match[op1_group]);
                                    p2 = getValue(match[op2_group]);
                                    checkNoExtraArg('STORE', match[op3_group]);

                                    if (p1.type === "register" && p2.type === "number" )
                                        opCode = opcodes.STORE_TO_MEMORY;
                                    else
                                        throw "LOAD does not support this operands";

                                    code.push(opCode<<4 | p1.value, p2.value);
                                    break;
                                case 'STOREP':
                                    p1 = getValue(match[op1_group]);
                                    p2 = getValue(match[op2_group]);
                                    checkNoExtraArg('LOADP', match[op3_group]);
                                    if (p1.type === "register" && p2.type === "register")
                                        opCode = opcodes.STORE_TO_POINTER;
                                    else
                                        throw "STOREP does not support this operands";

                                    code.push(opCode<<4|p1.value, p2.value);
                                    break;
                                case 'JUMP':
                                    p1 = getValue(match[op1_group]);
                                    p2 = getValue(match[op2_group]);
                                    checkNoExtraArg('JUMP', match[op3_group]);

                                    if (p1.type === "register" && p2.type === "number" )
                                        opCode = opcodes.JUMP_IF_EQUAL;
                                    else
                                        throw "JUMP does not support this operands";

                                    code.push(opCode<<4 | p1.value, p2.value);
                                    break;
                                case 'JUMPL':
                                    p1 = getValue(match[op1_group]);
                                    p2 = getValue(match[op2_group]);
                                    checkNoExtraArg('JUMPL', match[op3_group]);

                                    if (p1.type === "register" && p2.type === "number" )
                                        opCode = opcodes.JUMP_IF_LESS;
                                    else
                                        throw "JUMPL does not support this operands";

                                    code.push(opCode<<4 | p1.value, p2.value);
                                    break;
                                case 'AND':
                                    p1 = getValue(match[op1_group]);
                                    p2 = getValue(match[op2_group]);
                                    p3 = getValue(match[op3_group]);
                                    if (p1.type === "register" && p2.type === "register" && p3.type === "register")
                                        opCode = opcodes.AND;
                                    else
                                        throw "AND does not support this operands";

                                    code.push(opCode<<4|p1.value, p2.value<<4|p3.value);
                                    break;
                                case 'OR':
                                    p1 = getValue(match[op1_group]);
                                    p2 = getValue(match[op2_group]);
                                    p3 = getValue(match[op3_group]);
                                    if (p1.type === "register" && p2.type === "register"  && p3.type === "register")
                                        opCode = opcodes.OR;
                                    else
                                        throw "OR does not support this operands";

                                    code.push(opCode<<4|p1.value, p2.value<<4|p3.value);
                                    break;
                                case 'XOR':
                                    p1 = getValue(match[op1_group]);
                                    p2 = getValue(match[op2_group]);
                                    p3 = getValue(match[op3_group]);
                                    if (p1.type === "register" && p2.type === "register"  && p3.type === "register")
                                        opCode = opcodes.XOR;
                                    else
                                        throw "XOR does not support this operands";

                                    code.push(opCode<<4|p1.value, p2.value<<4|p3.value);
                                    break;
                                case 'ROT':
                                    p1 = getValue(match[op1_group]);
                                    p2 = getValue(match[op2_group]);
                                    checkNoExtraArg(instr, match[op3_group]);
                                    if (p1.type === "register" && p1.value === 0 && p2.type === "number" )
                                        opCode = opcodes.ROTATE;
                                    else
                                        throw "ROTATE does not support this operands";

                                    code.push(opCode<<4|p1.value, p2.value);
                                    break;

                                default:
                                    throw "Invalid instruction: " + match[2];
                            }
                        }
                    } else {
                        // Check if line starts with a comment otherwise the line contains an error and can not be parsed
                        var line = lines[i].trim();
                        if (line !== "" && line.slice(0, 1) !== ";") {
                            throw "Syntax error";
                        }
                    }
                } catch (e) {
                    throw {error: e, line: i};
                }
            }

            // Replace label
            for (i = 0, l = code.length; i < l; i++) {
                if (!angular.isNumber(code[i])) {
                    if (code[i] in labels) {
                        code[i] = labels[code[i]];
                    } else {

                        throw {error: "Undefined label: " + code[i]};
                    }
                }
            }

            return {code: code, mapping: mapping, labels: labels};
        }
    };
}]);
